<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="google-site-verification" content="LYZAMZyp5IGDHDRhRMjN0VoDglk1rEoj9nYv62BRxfQ" />
        <title>snow-dev.com :: Next level dotfiles with Ansible</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="stylesheet" href="../css/fontawesome.min.css">
        <link rel="stylesheet" href="../css/fontawesome-solid.min.css">
        <link rel="stylesheet" href="../css/fontawesome-brands.min.css">
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">snow-dev.com</a>
            </div>
            <nav>
                <a href="../" title="Home"><i class="fas fa-home"></i></a>
                <a href="../about.html" title="About"><i class="fas fa-info"></i></a>
                <a href="../archive.html" title="Archive"><i class="fas fa-archive"></i></a>
                <a href="../atom.xml" title="Atom Feed"><i class="fas fa-atom"></i></a>
                <a href="../rss.xml" title="RSS Feed"><i class="fas fa-rss"></i></a>
                <a href="https://github.com/snowiow" title="Github"><i class="fab fa-github"></i></a>
            </nav>
        </header>
          <main role="main">
              <h1>Next level dotfiles with Ansible</h1>
              <article>
    <section class="header">
        Posted on 2019-10-11
    </section>
    <hr class="section-head">
    <section>
        <p>In the life of every linux enthusiast comes the point, where he has a lot of individual configuration build up and wants to migrate these settings over to another machine as seamlessly as possible. At this point a whole philosophy of how to do this is coming into play. Today this philosophy is bundled under the name: <em>dotfiles</em>. Historically dotfiles are the config files, which lie in your home directory. Because they try to be invisible to the user they start with a dot (which is the linux convention for invisible files).</p>
<p>I started the classical approach like many others and kept <a href="https://github.com/snowiow/dotfiles">a git repository</a> with all the important dotfiles I want to share between my machines. A shell script lies in the root directory, which symlinks everything inside the <em>dotfiles</em> sub directory to the <em>home</em> directory. In the beginning this was great. All my important applications, like vim, were configured after executing the shell script. From that point on I could change my configuration files, which were synced back to the git repository. When I was at new consistent state, which I wanted to share, I did a git push. Afterwards I could pull the changes onto my other machines. My main concern with this approach arised when more and more application implemented the <a href="https://www.freedesktop.org/wiki/Software/xdg-user-dirs/">xdg-user-dir</a>. Now most of the dotfiles were located in my <em>.config</em> directory and the symlink linked to <em>~/.config</em> itself. Now I had to differentiate a lot between files I want to track and those I don’t before every commit. Long story short: I found a new and better approach, which I want to present to you: <a href="https://www.ansible.com/">Ansible</a>.</p>
<p>You might think now: “Ansible? Really? That’s total overkill for syncing dotfiles!” That’s true, but on the other hand it’s much more than just for syncing my dotfiles. But first of all for everyone, who never heard about Ansible. Ansible is a project written in Python, which helps you create reproducible systems. The normal use case for Ansible is as a configuration manager. Ansible projects mostly consist of YAML files, in which you define a want to state of a system. Then you apply this state to a system and Ansible syncs everything between the system and your YAML files. So in many ways it can be compared to Terraform, which I talked a lot about in my previous posts. But I see Ansible on a level lower than Terraform. While Terraform is about the big picture representing your whole infrastructure consisting of many virtual Servers and other cloud services, Ansible takes care about each and every system in this infrastructure. So it is more like docker, but you install and configure stuff on the system itself. Ok, this should be enough of an intro to Ansible. Also because we don’t use it in it’s intended way here…</p>
<p>Let’s dive into my totally over engineered dotfiles!</p>
<h1 id="getting-a-base-structure-built-up">Getting a base structure built up</h1>
<p>Normally you provision other systems from one operator system, mostly via SSH. But we want to use Ansible on the current system. Sure it would also be cool, to provision a new system from some sort of main machine, but in reality it was never necessary for me. So the first thing we do, is to tell Ansible we want to execute everything on localhost. Therefore we create a <a href="https://github.com/snowiow/snow/blob/master/hosts"><em>hosts</em></a> file in our new dotfiles directory, with the following line of code:</p>
<pre><code>[local]
localhost ansible_connection=local</code></pre>
<p>This will tell Ansible which hosts to provision.</p>
<p>Now we need to talk about two important concepts of Ansible. The first one are playbooks. Playbooks are Ansible’s infrastructure as code so to say. They demonstrate the want to be state of a system and are described in a descriptive manner in form of YAML files. The Ansible docs describe playbooks as the instruction manual for configuration, deployment and orchestration.</p>
<p>The second important concept are roles. Ansible roles are a form of structuring your playbooks and make them reproducible. We mainly use roles to structure our dotfiles and keep different application configurations separated. For example I reuse my roles in different forms for my Linux and OSX machine, because the installation process is different, but the configuration is the same. Roles dictate a special directory structure. This way Ansible is able to magically run those roles without setting too much manually. I will go into more detail, when we create our first role. All roles are located in the <a href="https://github.com/snowiow/snow/tree/master/roles">roles sub directory</a>.</p>
<h1 id="create-your-first-role">Create your first role</h1>
<p>As an example we install neovim, but this can be any software you want to always have installed. For this, we create a <code>nvim</code> sub directory in the <code>roles</code> directory. In the <code>nvim</code> sub directory we create a <code>tasks</code> sub directory. So the current directory structure should look like this:</p>
<p><img src="../images/ansible_directory_structure_1.png" alt="Ansible Directory Structure" title="Ansible Directory Structure" /></p>
<p>In the <em>tasks</em> directory we create a file called <em>main.yml</em>. This file is the starting point of a role and will be called automatically. Here we add the following instruction:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> install neovim on linux</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="fu">package:</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="fu">name:</span></a>
<a class="sourceLine" id="cb2-4" title="4">      <span class="kw">-</span> neovim</a>
<a class="sourceLine" id="cb2-5" title="5">      <span class="kw">-</span> python-pynvim</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="fu">state:</span><span class="at"> present</span></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="fu">become:</span><span class="at"> </span><span class="ch">yes</span></a></code></pre></div>
<p>Basically everything in playbooks is defined in these YAML blocks. They follow a common structure starting with an optional name, which is printed during execution. So that you know what’s currently done. Then the following key specifies a module, which does some sort of operation. There are many prebuild <a href="https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html">modules</a>, which are shipped with Ansible. Of course you can also <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html">write your own module</a>, but the amount of choice is so overwhelming, that I never ran into this situation.</p>
<p>The <a href="https://docs.ansible.com/ansible/latest/modules/package_module.html">package module</a> does the operation of downloading a package with your systems package manager for example. If you execute this on an Arch Linux machine, a package is downloaded via Pacman. If you execute this on Mac OSX, homebrew is used. There are also the respective modules for <a href="https://docs.ansible.com/ansible/latest/modules/pacman_module.html">Pacman</a> and <a href="https://docs.ansible.com/ansible/latest/modules/homebrew_module.html">homebrew</a>, if you already know that you execute this playbook on this specific OS.</p>
<p>Every module has some mandatory and optional parameters. See the <a href="https://docs.ansible.com/ansible/latest/modules/package_module.html#parameters">package module</a> for example. These are set inside of the <em>package</em> block. The first parameter <em>name</em> takes one or more names of packages. The second parameter <em>state</em> tells if the packages defined under <em>name</em> should be present or absent. Also there is an optional parameter <em>use</em>, where you can define which package manager to use. In our example we omit this parameter, which results in Ansible searching for the correct one to use on your system.</p>
<p>Now you can also see why I was talking about the declarative nature of Ansible. We don’t tell Ansible what and how something needs to be done. We just tell what we want to have. We want to have neovim and the python package neovim present on the system. Ansible takes care about the rest. In a normal shell script for example we would need to explicitly tell, with which package manager we want to download a specific package and only if this package isn’t already installed. Otherwise do nothing.</p>
<p>The last part of this snippet (<em>become: yes</em>) says that this block should be executed as root. This is outside of the package block, because it’s not specific to this module, but can be appended to every block. In this case we need to be root, because normally only root users are able to install new software via the package manager.</p>
<p>Now let’s execute this role. First we need a new YAML file, which we specifically execute by Ansible. In this file we also define the roles, which should be executed. Let’s create a file call <em>roles.yml</em> in the root directory with the following content:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> Setup local environment</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="fu">hosts:</span><span class="at"> localhost</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="fu">roles:</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">-</span> nvim</a></code></pre></div>
<p>As always we give this block a name and set the desired host. This represents the key of the hosts init file, we defined in the beginning. Ansible will take the stuff under that key and execute the roles, which are defined afterwards, on this host.</p>
<p>Now we execute the Ansible playbook script via:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">ansible-playbook</span> --ask-become-pass -i hosts roles.yml</a></code></pre></div>
<p>The <em>–ask-become-pass</em> flag needs to be given, because we have at least one block, which needs root access. This causes Ansible to ask for your password in the beginning, so Ansible can execute the according blocks as <em>sudo</em>. The <em>-i</em> flag specifies the inventory, where the hosts are defined. In our case we pass the <em>hosts</em> file. As the main argument we pass Ansible the <em>roles.yml</em>, which then executes the roles defined in that file. This should give you something like this output (if you already have those packages installed) or a slightly different output. Also this should be executable by every Linux distribution as long as the package names match.</p>
<p><img src="../images/ansible_output_1.png" alt="Ansible Output" title="Ansible Output" /></p>
<p>As a quality of live addition I would create a shell script called <a href="https://github.com/snowiow/snow/blob/master/install">install</a> or something, which itself executes the <em>ansible-playbook</em> command above, because the command itself is very daunting to type over and over again. I also use the shell script for executing <em>ansible-playbook</em> with different flags on different systems and passing environment variables, which are then used by Ansible.</p>
<h1 id="symlink-nvim-dotfiles">Symlink nvim dotfiles</h1>
<p>Now we want to symlink some dotfiles for neovim. In this example we will only symlink the <em>init.vim</em> file. First place your <em>init.vim</em> into the <em>files</em> directory, which we created earlier in the nvim role. Then we add a new block to the <em>main.yml</em> in the nvim role:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> symlink init.vim</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">file:</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="fu">src:</span><span class="at"> </span><span class="st">&quot;{{ ansible_env.PWD }}/roles/nvim/files/init.vim&quot;</span></a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="fu">path:</span><span class="at"> </span><span class="st">&quot;~/.config/nvim/init.vim&quot;</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="fu">state:</span><span class="at"> link</span></a></code></pre></div>
<p>Because you now understand Ansible playbooks, you can easily read the above block. First we have a name again, which tells us to symlink the init.vim file. Then we make use of the file module of Ansible. As the source we give it the path to our <em>init.vim</em> file. As the path we give it the destination. As the desired state we want to have a link between the source and path.</p>
<p>Executing the playbook again, will now also create the symlink and nvim should now have the settings you normally use. When you do changes to your config and the ansible project is checked into git, you can now automatically sync these changes with your other machines. On the other machines you just clone the repository, execute ansible once and from then on all the files, which are symlinked, are synced automatically. You only need to execute Ansible again, if you added new software, which needs to be synced as well between your machines.</p>
<p>Of course there are also loops to symlink more than one file and directory. You can look it up in my <a href="https://github.com/snowiow/snow/blob/master/roles/nvim/tasks/config.yml">current nvim playbook</a>. I also have a lot of other parts automated, like downloading a vim package manager and downloading all the defined packages from my <em>init.vim</em>. I won’t cover everything here, because this should only be a small overview of how I handle my system setups. If you are curios, you can check my <a href="https://github.com/snowiow/snow">ansible dotfiles repository</a> out and look around yourself. You now should be able to read and understand everything in this repository because the concepts, described before are repeated over and over again.</p>
<h1 id="handle-different-kind-of-systems">Handle different kind of systems</h1>
<p>In this last part I want to present how I use one role for different systems. The most common example I ran into was Pacman requiring root and homebrew denying being executed as root.</p>
<p>For this case I created two files <em>install_dawin.yml</em> and <em>install_linux.yml</em> in which I defined the different instructions for installing neovim on Linux and on Mac OSX. My Linux version looks like the <em>main.yml</em> from before and my Mac Version looks like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> install neovim on darwin</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="fu">homebrew:</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="fu">name:</span><span class="at"> neovim</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="fu">state:</span><span class="at"> present</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">-</span> <span class="fu">name:</span><span class="at"> install python-neovim on darwin</span></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="fu">pip:</span></a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="fu">name:</span><span class="at"> neovim</span></a></code></pre></div>
<p>As you can see I need to get python-neovim from pip this time, because it isn’t available in homebrew. But even big differences like this are easy to handle with splitting some blocks in OS specific variants.</p>
<p>The <code>main.yml</code> of the role got changed to this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">-</span> <span class="fu">import_tasks:</span><span class="at"> install_darwin.yml</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="fu">when:</span><span class="at"> ansible_facts['os_family'] == &quot;Darwin&quot;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">-</span> <span class="fu">import_tasks:</span><span class="at"> install_linux.yml</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="fu">when:</span><span class="at"> ansible_facts['os_family'] == &quot;ArchLinux&quot;</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">-</span> <span class="fu">import_tasks:</span><span class="at"> config.yml</span></a></code></pre></div>
<p>Here I import the install tasks based on the OS family. Ansible collects some facts about the system, it’s running on in a dictionary. This can be accessed like in the code snippet above. Afterwards I import the config task, which executes everything to configure neovim to my liking. These things are all independent of the underlying OS and can be executed in any case.</p>
<h1 id="conclusion">Conclusion</h1>
<p>First of all these are the basics of some of my system setup. There is a lot more different stuff to discover. But with the things I have shown you, it should be easy to pick up for your dotfiles as well.</p>
<p>Also big thanks to <a href="https://www.youtube.com/watch?v=__0Dquj7y9g">Greg Hurrel</a> from whom I got the base idea of using ansible for my system setup. Also <a href="https://github.com/wincent/wincent">hist dotfiles</a> are a lot more sophisticated than mine. I use it time and time again to look up stuff and use them in my dotfiles. However I think it’s important to start like described in this post, to really create your own Ansible dotfiles repository. It’s totally okay to copy over things, but I think you shouldn’t start with mine or his dotfiles as a basis, because this will force you in a corner, which maybe isn’t the way you wanted to originally design your dotfiles repository.</p>
<p>I download Ansible from the package manager of my OS, clone the repository and execute it. I decided not to pull in Ansible as a third party dependency in the repository because:</p>
<ol type="1">
<li>It’s basically available on any systems package manager anyway and therefore easy to install</li>
<li>You depend again on other python dependencies, which are needed by Ansible</li>
</ol>
<p>Especially reason 2 is very problematic, because if you use the universal way of installing python packages via pip. You get problems with your systems package manager and if other installed packages have the same dependencies as Ansible does. Your Package manager won’t notice that the dependency was already installed there via pip and will fail overriding the files. Trying to solve this issue by using virtual environments brought even more problems to the table because I needed even more dependencies. That’s why I went with just doing</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="fu">sudo</span> pacman -S ansible</a></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="ex">brew</span> install ansible</a></code></pre></div>
<p>instead of pulling the whole dependency hell into my dotfiles repo.</p>
<p>The last thing I want to mention is that this is only one way of managing system setup/dotfiles. If you just want to symlink your stuff and nothing else. Most probably then this isn’t worth the effort. However if you also want to automate other stuff of your system setup and aren’t comfortable with one of the many options out there, you should definitely give Ansible a chance. It’s very easy to pick up and thanks to the documentation it’s easy to discover new things. Also creating something like this (which has a practical use case for almost all of us) gives you a good entry point in how to use Ansible and gives you the knowledge to dig deeper and do even more with it. Ansible today is still a very needed skill in the DevOps space.</p>
<p>Thanks for reading. I’m happy to hear your approaches for your system setup or how you handle specific things with Ansible.</p>
    </section>
</article>

          </main>
          <footer>
            <nav>
                <a href="../impressum.html" title="Impressum">Impressum</a>
                <a href="../datenschutz.html" title="Datenschutz">Datenschutz</a>
            </nav>
          </footer>
    </body>
</html>
